# 시간 복잡도와 공간 복잡도

## Big-O 표기법 (on the order of)

Big-O 표기법은 입력 크기 n이 커질수록 알고리즘이 수행하는 연산 횟수의 상한을 표현합니다.

이때, Big-O 표기법에서는 상수와 저차항이 무시됩니다.
즉, 연산 시간이 O(2n)이나 O(3n+5)처럼 표현될 수 있지만, Big-O 표기법에서는 주된 증가 요인만 남기고 상수는 생략하여 O(n)으로 단순화됩니다.
예시:

O(2n) → O(n)
O(3n^2 + 5n + 10) → O(n^2)
이렇게 표기하는 이유는 입력 크기가 매우 커질 때 상수 항이 성능에 미치는 영향이 미미하기 때문입니다.

따라서 알고리즘 분석 시에는 상수보다는 시간 증가의 패턴을 더 중요하게 봅니다.


## 시간 복잡도 (Time Complexity)

#### 시간 복잡도는 입력 크기(n)가 증가할 때 알고리즘이 실행되는 데 걸리는 시간의 증가율을 나타냅니다. 주로 **빅오 표기법(Big-O Notation)**을 사용하여 나타내며, 가장 빠르게 증가하는 항만 고려합니다.


- O(1): 상수 시간 복잡도
  - 데이터의 크기와 무관하게 동일한 시간이 소요되는 알고리즘입니다.
  예시: 배열의 첫 번째 값을 조회하는 연산, 배열에서 특정 인덱스의 값을 읽기
  
  
- O(log n): 로그 시간 복잡도
  - 입력 크기가 커질수록 증가하는 속도가 느려지는 알고리즘입니다.
  이진 탐색(binary search)처럼 데이터의 절반을 한 번에 버릴 수 있는 경우에 주로 발생합니다. (참고로 log의 밑도 상수로 취급해서 일반화합니다)
  

- O(n): 선형 시간 복잡도
  - 입력 크기에 비례해 시간이 증가하는 알고리즘입니다. 데이터를 한 번씩 모두 확인해야 하는 경우 주로 발생합니다.
  예시: 배열의 모든 값을 순차적으로 확인하는 선형 탐색(linear search).


- O(n log n): 로그 선형 시간 복잡도
  - 빠른 정렬 알고리즘, 예를 들어 퀵 정렬(Quick Sort)이나 병합 정렬(Merge Sort)에서 나타납니다.
  데이터 크기가 커질 때 상대적으로 효율적입니다.
  예시: 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort) 평균

  
- O(n^2): 이차 시간 복잡도
  - 이중 반복문처럼, 모든 요소를 두 번씩 확인해야 할 때 발생하는 시간 복잡도입니다.
  예시: 버블 정렬(Bubble Sort), 선택 정렬(Selection Sort)과 같은 단순한 정렬 알고리즘.

  
- O(2^n): 지수 시간 복잡도
  - 입력이 하나 증가할 때마다 실행 시간이 두 배로 증가하는 알고리즘입니다.
  보통 재귀적인 문제나 백트래킹 문제에서 나타납니다.
  예시: 피보나치 수열을 계산하는 단순 재귀 알고리즘. 

  
- O(n!): 팩토리얼 시간 복잡도
  - 매우 비효율적인 시간 복잡도로, 데이터의 모든 가능한 순열을 확인해야 하는 경우 발생합니다.
  예시: 순열을 전부 확인하는 완전 탐색 알고리즘. 외판원 문제(Brute Force)


예시)
```
# O(n) 시간 복잡도를 가지는 예제: 리스트의 합 구하기
def sum_list(arr):
    total = 0
    for num in arr:
        total += num
    return total
```

-> 위 코드는 리스트 크기 n에 따라 반복 횟수가 증가하므로 O(n)입니다.


## 공간 복잡도 (Space Complexity)
#### 공간 복잡도는 알고리즘이 실행될 때 추가적으로 사용하는 메모리 양을 나타냅니다.


- O(1): 상수 공간 복잡도
  - 알고리즘이 추가적인 메모리를 거의 사용하지 않는 경우.
  예시: 입력 크기와 상관없이 몇 개의 변수를 사용하는 경우 (ex. 값 교환 알고리즘).
  

- O(n): 선형 공간 복잡도
  - 알고리즘이 입력 크기 n에 비례해서 메모리를 사용하는 경우.
  예시: 새로운 배열을 생성하거나 리스트에 데이터를 저장하는 경우.


- O(n^2): 이차 공간 복잡도
  - 이중 배열이나 이중 리스트 등, 데이터 구조가 이차원적으로 증가할 때 발생.
    예시: 2차원 배열을 사용하는 행렬 연산.
  

예시) 
```
# O(n) 공간 복잡도 예제: 새로운 리스트에 제곱 값을 저장
def square_list(arr):
    result = []
    for num in arr:
        result.append(num ** 2)
    return result
```

-> 리스트 크기 n에 비례하여 새로운 리스트가 생성되므로 O(n)입니다.

##  시간 복잡도와 공간 복잡도 최적화
#### 알고리즘을 최적화할 때는 시간 복잡도와 공간 복잡도 사이의 균형이 중요합니다.

#### 때로는 더 많은 메모리를 사용해서 시간을 절약하거나, 반대로 시간이 더 걸리더라도 메모리를 절약할 수 있습니다. 이러한 균형은 주로 동적 프로그래밍(Dynamic Programming)에서 자주 고려됩니다.

- 메모이제이션(Memoization): 중복 계산을 피하기 위해 메모리를 더 사용하여 시간을 절약하는 방식.
예를 들어, 피보나치 수열을 동적 프로그래밍으로 풀 때는 중간 결과를 저장해 O(n)의 시간 복잡도를 달성하지만, 저장 공간이 O(n)으로 증가합니다.

- 불필요한 반복문 제거 → O(n²) → O(n log n)으로 최적화 가능
- 불필요한 리스트 사용 줄이기 → 공간 복잡도 O(n) → O(1)으로 개선
- 정렬된 데이터 활용 → 이진 탐색(O(log n)) 사용