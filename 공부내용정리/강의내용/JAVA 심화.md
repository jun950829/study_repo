# JAVA 심화 정리

## Object 클래스

### 모든 클래스는 Object 클래스를 상속 받는다

- 모든 클래스의 최상위 클래스
- object클래스의 메서드 중 일부는 재정의해서 사용할 수 있음
- 컴파일러가 extends Ojbect를 추가함

#### equals
- 두 인스턴스의 주소 값을 비교
- 재정의 하여 두 인스턴스가 논리적으로 동일함의 여부를 구현
- 인스턴스가 다르더라도 논리적으로 동일한 경우 true 반환 하도록 재정의 가능

#### hashCode()
- hashCode()는 인스턴스의 저장 주소를 반환
- 힙메모리에 인스턴스가 저장되는 방식이 hash 방식
- hash: 정보를 저장, 검색하는 자료구조
- 자료의 특정 값에 대한 저장 위치를 반환해주는 해시 함수 사용

```
index = hash(key)
// 저장위치 = 해시함수 ( 객체 정보 )

```

- 두 인스턴스가 같다는 것은? -> 두 인스턴스에 대한 equals  반환 값이 true, 동일한 hashCode값을 반환

#### clone()
- 객체의 원본을 복제하는데 사용
- 생성과정의 복잡한 과정을 반복하지 않고 복제
- clone메서드를 사용하면 객체의 정보가 동일한 또 다른 인스턴스가 생성되는 것이므로, 객체 지향 프로그램에서의 정보 은닉, 객체 보호의 관점에 위배
- 해당 클래스의 clone 메서드의 사용을 허용한다는 의미로 cloneable 인터페이스를 명시


## String 클래스

### string 클래스
- string 선언
```
String str1 = new String("abc");
String str2 = "abc"
```

- 힙 메모리에 인스턴스로 생성되는 경우와 상수 풀에 있는 주소를 참조하는 두가지 방법
- 힙 메모리는 생성될때마다 다른 주소 값을 가지지만, 상수 풀의 문자열은 모두 같은 주소를 가짐
- 한번 생성된 String dms qnfqus
- String 을 연결 하면 기존의 String에 연결되는 것이 아닌 새로운 문자열이 생성

### StringBuilder, StringBuffer
- 내부적으로 가변적인 char[]를 멤버 변수로 가짐
- 문자열을 여러번 연결하거나 변경할 때 사용하면 유용
- 새로운 인스턴스를 생성하지 않고 char[]를 변경함
- stringbuffer 는 멀티쓰레드 프로그래밍에서 동기화를 보장
- 단일 쓰레드 프로그램에서는 stringbuilder 사용을 권장
- toString()메서드로 String 변환

### text block
- 문자열을 """ """ 사이에 이어서 사용 가능
- html, json 문자열을 만드는데 유용하게 사용가능
```
String strBlock = """
    <html>
        <body>
            <span>example</span>
        </body>
    </html>
""";
```

## Class 클래스
- 자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일이 생성
- Class 클래스는 컴파일 된 class 파일을 로드하여 객체를 동적 로드하고, 정보를 가져오는 메서드가 제공됨
- Class.forName("클래스 이름") 메서드로 클래스를 동적으로 로드 함
```
Class c = Class.forName("java.lang.String");
```
- 클래스 이름으로 직접 Class 클래스 가져오기
```
Class c = String.class;
```
- 생성된 인스턴스에서 Class 가져오기
```
String s = new String();
Class c = s.getClass();
```

#### 동적로딩
- 컴파일 시에 데이터 타입이 binding 되는 것이 아닌 실행(runtime) 중에 데이터 타입을 binding 하는 방법
- 프로그래밍 시에는 문자열 변수로 청리했다가 런타임시에 원하는 클래스를 로딩하면 binding 할 수 있다는 장점
- 컴파일 시에 타입이 정해지지 않으므로 동적 로딩시 오류가 발생하면 프로그램의 심각한 장애가 발생 가능

#### 클래스 정보 알아보기
- reflection 프로그래밍: class 클래스를 사용하여 클래스의 정보( 생성자, 변수, 메서드 ) 등을 알 수 있고 인스턴스를 생성하고 메서드를 호출하는 방식의 프로그래밍
- 로컬 메모리에 객체 없는 경우, 원격 프로그래밍, 객체의 타입을 알 수 없는 경우에 사용
- java.lang.reflect 패키지에 있는 클래스를 활용하여 프로그래밍
- 일반적으로 자료형을 알고 있는 경우엔 사용하지 않음



## 자료구조

### 자료구조란 무엇인가
- 프로그램에서 사용할 많은 데이터를 메모리 상에서 관리하는 여러 구현방법들
- 효울적인 자료구조가 성능 좋은 알고리즘의 기반이 됨
- 자료의 효울적인 관리는 프로그램의 수행속도와 밀접한 관련이 있음
- 여러 자료 구종 중에서 구현하려는 프로그램에 맞는 최적의 ㅏ료구조를 활용해야 하므로 자료구조에 대한 이해가 중요함

### 자료구조엔 어떤 것들이 있나
### 1. 한 줄로 자료 관리하기 ( 선형 자료 구조 )
- 배열 : 선형으로 자료를 관리, 정해진 크기의 메모리를 먼저 할당 받아 사용하고, 자료의 물리적인 위치와 논리적인 위치가 같음
- 연결 리스트 (LinkedList) :  선형으로 자료를 관리, 자료가 추가될 때마다 메모리를 할당 받고, 자료는 링크로 연결됨. 자료의 물리적 위치와 논리적 위치가 다를 수 있음, index 연산 불가능, 그러므로 항상 처음부터 찾아야함
- 스택: 가장 나중에 입력 된 자료가 가장 먼저 출력 되는 자료 구조(Last In First Out) -> 맨 끝에서만 자료의 입출력이 일어남
- 큐: 가장 먼저 입력된 자료가 가장 먼저 출력되는 자료 구조 (First In First Out ) -> 맨 끝에서만 자료의 입출력이 일어남

### 2. 비 선형 자료구조
#### 트리: 부모 노드와 자식 노드간의 연결로 이루어진 자료구조
  Heap: Priorty queue를 구현 ( 우선 큐 )
  max heap: 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우
  min heap: 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는 경우
  heap정렬에 활용

- 이진 트리: 부모 노드에 자식 노드가 두개 이하인 트리

#### 이진 검색트리
- 자료의 중복을 허용하지 않음
- 왼쪽 자식 노드는 부모 노드보다 작은 값, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가짐
- 자료를 검색에 걸리는 시간이 평균 log(n)
- inorder traversal 탐색을 하게되면 자료가 정렬되어 출력

#### 그래프: 정점과 간선들의 유한 집합 G = ( V, E)
  - 정점: 여러 특성을 가지는 객체, 노드
  - 간선: 이 객체들의 연결 관계를 나타냄, 링크
  - 간선은 방향성이 있는 경우와 없는 경우가 있음
  - 그래프를 구현하는 방법: 인접행렬, 인접리스트
  - 그래프를 탐색하는방법: BFS(bread frist search), DFS(depth first search)

#### 해싱: 자료를 검색하기 위한 자료 구조
- 검색을 위한 자료구조
- key에 대한 자료를 검색하기 위한 사전 개념의 자료 구조
- key는 유일하고 이에 대한 value를 쌍으로 저장
- index = h(key): 해시 함수가 key에 대한 인덱스를 반환해줌 해당 인덱스 위치에 자료를 저장하거나 검색하게됨
- 해시 함수에 의해 인덱스 연산이 산술적으로 가능 O(1)
- 저장되는 메모리 구조를 해시테이블이라함


## 제네릭 (Generic) 프로그래밍

### 제네릭 자료형 정의
- 클래스에서 사용하는 변수의 자료형이 여러개 일 수 있고, 그 기능은 동일한 경우 클래스의 자료형을 특정하지 않고 추후 해당 클래스를 사용할 때 지정할 수 있도록 선언
- 실제 사용되는 자료형의 반환은 컴파일러에 의해 검증되므로 안정적인 프로그래밍 방식
- 컬렉션 프레임워크에서 많이 사용됌
- 자료형 매개변수 (type parameter): 이 클래스를 사용하는 시점에 실제 사용할 지료형을 지정, static 변수는 사용할 수 없음
- GenericPrinter: 제네릭 자료형
- E: element, K: key, V: value 등 여러 알파벳을 의미에 따라 사용가능

### <T extends 클래스>
- T 자료형의 범위를 제한 할 수 있음
- 상위 클래스에서 선언하거나 정의하는 메서드를 활용할 수 있음
- 상속을 받지 않는 경우 T는 Object로 변환되어 Object 클래스가 기본으로 제공하는 메서드만 사용가능

#### T extends를 사용한 프로그래밍
- GenericPrinter 에 material 변수의 자료형을 상속받아 구현
- T에 무작위 클래스가 들어갈 수 없게 Material 클래스를 상속받은 클래스로 한정

### 컬렉션 프레임 워크
- 프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK 라이브러리
- java.util에 구현
- 개발에 소요되는 시간을 절약하면서 최적화 된 알고리즘을 사용할 수 있음
- 여러 구현 클래스와 인터페이스의 활용에 대한 이해가 필요함


### Collection 인터페이스
- 하나의 객체를 관리하기 위한 메서드가 선언된 인터페이스의
- 하위에 List와 Set인터페이스가 있음

#### List 인터페이스
- 객체를 순서에 따라 저장하고 관리하는데 필요한 메서드가 선언된 인터페이스
- 자료구조 리스트(배열, 연결리스트)의 구현을 위한 인터페이스
- 중복을 허용
- ArrayList, Vector, LinkedList, Stack, Queue 등

#### Set 인터페이스
- 순서와 관계없이 중복을 허용하지 않고 유일한 값을 관리하는데 필요한 메서드가 선언됨 =
- 아이디, 주민번호, 사번등을 관리하는데 유용
- 저장된 순서와 출력되는 순서는 다를 수 있음
- HashSet, TreeSet 등

#### Map 인터페이스
- 쌍으로 이루어진 객체를 관리하는데 사용하는 메서드들이 선언된 인터페이스
- 객체는 key-value의 쌍으로 이루어짐
- key는 중복을 허용하지 않음
- HashTable, HashMap, Properties, TreeMap 등의 Map 인터페이스를 구현함

### 요소의 순회란
- 컬렉션 프레임워크에 저장된 요소들을 하나씩 차례로 참조하는 것
- 순서가 있는 List 인터페이스의 경우는 Iterator를 사용하지 않고 get(i) 메서드를 활용 가능
- Set 인터페이스의 경우 get(i)  메서드가 제공되지 않으므로 Iterator를 활용하여 객체를 순회함


## 내부 클래스
- 클래스 내부에 선언한 클래스로 이 클래스를 감싸고 있는 외부 클래스와 밀접한 연관이 있는 경우가 많다=
- 중첩 클래스라고도 함
- 내부 클래스의 종류
  - 인스턴스 내부 클래스, 정적 내부 클래스, 지역 내부 클래스, 익명 내부 클래스

### 인스턴스 내부 클래스
- 내부적으로 사용할 클래스를 선언 ( private 권장 )
- 외부 클래스가 생성된 후 생성됨 ( 정적 내부 클래스와 다름 )
- private이 아닌 내부 클래스는 다른 외부 클래스에서 생성 할 수 있음

### 정적 내부 클래스
- 외부 클래스 생성과 무관하게 사용할 수 있음
- 정적 변수, 정적 메서드 사용

### 지역 내부 클래스
- 지역 변수와 같이 메서드 내부에서 정의하여 사용
- 메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라짐
- 메서드 호출 이후에도 사용해야 하는 경우가 있을 수 있으므로 지역 내부 클래스에서 사용하는 메서드의 지역 변수나 매개변수는 final로 선언

## 람다식

### 함수형 프로그래밍
- 함수의 구현과 호출만으로 프로그래밍이 수행되는 방식
- 함수형 프로그래밍 ( Functional Programming : FP )
  - 함수형 프로그래밍은 순수함수를 구현하고 호출함으로써 외부 자료에 부수적인 영향(side effect)를 주지 않도록 구현하는 방식. 순수 함수란 매개변수만들 하용하여 만드는 함수
  - 함수를 기반으로 하는 프로그래밍이고 입력받는 자료외에 외부 자료를 사용하지 않아 여러 자료가 동시에 수행되는 병렬처리가 가능. 함수형 프로그래밍은 함수의 기능이 자료에 독립적임을 보장

### 람다식 문법
- 익명 함수 만들기
- 매개 변수와 매개변수를 이용한 실행문 (매개변수) -> {실행문;}

### 함수형 인터페이스 선언하기
- 람다식을 선언하기 위한 인터페이스
- 익명 함수와 매개 변수만으로 구현되므로 인터페이스는 단 하나의 메서드만을 선언해야함
- @FunctionalInterace 어노테이션
- 람다식으로 구현한 인터페이스 객체를 변수처럼 활용가능 -> 매개변수로 함수를 넘길 수 있음
```
@FunctionalInterface
public interface Mynumber {
    int getMax(int num1, int num2)
    int add(int x, int y)
} // 이처럼 여러 함수 선언하면 에러남
```


## 스트림(Stream)
### 스트림이란
- 자료의 대상과 관계없이 동일한 연산을 수행
- 배열, 컬렉션을 대상으로 연산을 수행
- 일관성 있는 연산으로 자료의 처리를 쉽고 간단하게
- 자료 처리에 대한 추상화가 구현되었다고함
- 한번 생성하고 사용한 스트림은 재사용 불가
- 다른 연산을 수행하기위해서는 스트림을 다시 생성해야함
- 스트림 연산은 기존 자료를 변경하지 않음
- 스트림 연산은 중간 연산과 최종 연산으로 구분
- 스트림에 대해 중간 연산은 여러개의 연산이 적용될 수 있지만 최종 연산은 마지막에 한 번만 적용
- 따라서 중간 연산에 대한 결과를 연산 중에 알 수 있다 ( 지연 연산 )

ex)
```
int sumVal = Arrays.stream(arr).sum();
long count = Arrays.stream(arr).count();
```

### 중간 연산과 최종 연산
- 중간 연산의 예 -> filter(), map(), sorted() 등
- 최종 연산이 호출될 때 중간 연산이 수행되고 결과가 생성
- sorted 메서드를 사용하려면 객체에 정렬 방식에 대한 구현, comparable 인터페이스가 구현되어야함. 구현 되지 않은 경우에는 sorted() 매개변수로 comparator 인터페이스 구현객체를 지정할 수 있음

```
sList.stream().filter(s->s.length>=5).forEach(s->System.out.println(s));
```
-> filter()는 중간 연산, forEach는 최종 연산 

## Reduce 연산
- 정의된 연산이 아닌 프로그래머가 직접 구현한 연산을 적용
```
T reduce(T identity, BinaryOperator<T> accumulator)
```
- 최종 연산으로 스트림의 요소를 소모하여 연산을 수행
- 배열의 모든 요소의 합을 구하는 예시
```
Arrays.stream(arr).reduce(0, (a,b) => a+b));
```

- reduce()  메서드의 두 번재 요소로 전달되는 람다식에 따라 다양한 기능 할 수 있음
- 람다식을 직접 구현하거나 람다식이 긴경우 BinaryOperator를 구현한 클래스를 사용함
- 문자열 중 가장 긴 문자를 찾아내는 예시
```
String[] greetings = ["hi", "hello", "안녕", "안녕하세요"];

String maxString = Arrays.stream(greetings).reduce("", (s1, s2) -> {
    if(s1.getBtyes().length >= s2.getBytes().length)
        return s1;
    else return s2;
    }
};

System.out.println(maxString);
```


## 예외처리

### 프로그램에서의 오류
- 컴파일 오류
  - 프로그램 코드 작성 중 발생하는 문법적 오류 =
- 실행 오류
  - 실행 중인 프로그램이 의도하지 않은 동작으로 프로그램이 중지되는 오류
  - 실행 오류는 비정상 종료가 되는 경우 시스템의 심각한 장애를 발행할 수 없음

### 예외 처리의 중요성 
- 프로그램의 비정상 종료를 피하여 시스템이 원활이 실행되도록 함
- 실행 오류가 발생한 경우 오류의 과정을 재현하는 것은 불가능
- 오류가 발생한 경우 Log를 남겨서 추후 Log 원인을 파악하여 bug를 수정하는 것이 중요

### 오류와 예외 클래스
- 시스템 오류: 가상 머신에서 발생, 프로그래머가 처리할 수 없는 것
- 예외: 프로그램에서 제어할 수 있는 오류
- 자바는 안정성이 중요하므로 프로그램에서 발생하는 오류에 대해 문법적으로 예외 처리를 해야함

### 예외 클래스들
- Exception: 모든 예외 클래스의 최상위 클래스
  - Arithmetic Exception: 정수를 0으로 나눈 경우
  - NullPointer Exception: 초기화 되지 않은 Object사용
  - Interrupted Exception: Thread.sleep(), join(), Object의 wait()로 non-runnable 상태인 thread를 Runnable 하게 만들 수 있도록 사용할 수 있음
  

### 예외 처리와 미루기

#### try-catch 문
- try 블록에는 예외가 발생할 가능성이 있는 코드를 작성하고 try 블록 안에서 예외가 발생한 경우 catch 블록이 수행됨

#### try-catch-finally 문
- finally 블록에서 파일을 닫거나 네트웍을 닫는 등의 리소스 해제 구현
- try 블럭이 수행되는 경우, finally문도 항상 수행
- 여러 개의 예외 블럭이 있는 경우 각각에서 리소스를 해제하지 않고 finally 블로에서 해제하도록 구현

#### try-with-resources 문
- 리소스를 사용하는 경우 close 하지 않아도 자동으로 해제 되도록 함
- 리소스를 try 내부에서 선언해야만 함
- 해당 리소스 클래스가 AutoCloseable 인터페이스를 구현 해야함

### 예외처리 미루기
- 예외 처리는 예외가 발생하는 문자에서 try-catch 블록으로 처리하는 방법과 이를 사용하는 부분에서 처리하는 방법 두가지가 있음
- throws를 이용하면 예외가 발생할 수 있는 부분을 사용하는 문장에서 예외를 처리할 수 있음



## 스트림

### 입출력 스트림
- 네트워크에서 자료의 흐름이 물의 흐름과 같다는 비유에서 유래
- 자바는 다양한 입출력 장치에 독립적으로 일관성 있는 입출력을 입출력 스트림을 통해 제공

#### 입출력의 구분
- 대상 기준: 입력 / 출력 스트림
- 자료의 종류: 바이트 / 문자 스트림
- 기능: 기반 / 보조 스트림

#### 입력 스트림과 출력 스트림
- 스트림의 종류

|종류|예시|
|----|----|
|입력|FileInputStream, FileReader, BufferedInputStream, BufferedReader 등|
|출력|FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등|

## 직렬화 (serialization)
- 인스턴스의 상태를 그대로 파일 저장하거나 네트웍으로 전송하고 (serialization) 이를 다시 복원 (deserialization) 하는 방식
- 자바에서는 보조스트림을 활용하여 직렬화 제공
- ObjectInputStream과 ObjectOutputStream

### Serializable 인터페이스
- 직렬화는 인스턴스의 내용이 외부로 유츌되는 것이므로 프로그래머가 해당 객체에 대한 직렬화 의도를 표시해야함
- 구현 코드가 없는 marker interface
- transient: 직렬화 하지 않으려믄 맴버 변수에 사용 (Socket등 직렬화 할 수 없는 객체)

## Thread

### Thread 란
- process 실행 중인 프로그램, 프로그램이 실행되면 os로 부터 메모리를 할당 받아 프로세스 상태가 됌
-  하나의 프로세스는 하나 이상의 thread를 가지게 되고, 실제 작업을 수행하는 단위는 thread임

### multi-threading
- 여러 thread가 동시에 수행되는 프로그래밍, 여러 작업이 동시에 실행되는 효과
- thread는 각각 자신만의 작업 공간을 가짐 (context)
- 각 thread 사이에서 공유하는 자원이 있을 수 있음 ( ex - static instance )
- 여러 thread 가 자원을 공유하여 작업이 수행되는 경우 서로 자원을 차지하려는 race condition이 발생 할 수 있음
- 이렇게 여러 thread 가 공유하는 자원중 경쟁이 발생하는 부분을 critical section 이라고 함
- ciritical section에 대한 동기화를 구현하지 않으면 오류가 발생할 수 있음


## 소캣 ( Socket ) 
- 네트워크로 연결되 두 대의 호스트간에 통신을 위한 양쪽 끝을 연결
- 대표적 well known port
  - 7: Echo
  - 13: DayTime
  - 21: Ftp
  - 23: Telnet
  - 25: SMTP
  - 80: HTTP

### ServerSocket
- 서버소캣은 클라이언트와 통신할 수 있는 서버용 socket을 만들어 준다
- 생성과 접속 대기
  - ServerSocket ss = new ServerSocket(10000);
  - Socket socket = ss.accept();
- 서버소캣의 accept에서 리턴된 서버용 socket은 클라이언트 소캣으로 serversocket에 연결 요청할 때 accept가 반응
- accept 할 때 리턴된 서버용 socket은 자동으로 포트를 할당 받는다
```
    ServerSocket ss = new ServerSocket(10000);
    Socket socket = ss.accept();
    
    InputStream is = socket.getInputStream();
    OutputStream os = socket.getOutputStream();
```