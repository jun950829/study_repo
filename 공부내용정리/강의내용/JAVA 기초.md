# 인스턴스 생성과 힙 메모리

## 인스턴스

- 클래스는 객체의 속성을 정의, 기능을 구현하여 만든 상태
- 실제 클래스 기반으로 생성된 인스턴스는 각각 다른 맴버 변수 값을 가짐

## 힙 메모리
- 생성된 인스턴스는 동적 메모리 ( 힙 메모리 ) 에 할당
- c나 c++에서는 프로그래머가 일일히 해제 시켜야함
- 자바에서는 garbage collector가 주기적으로 사용하지 않는 메모리 대신 제거
- 하나의 클래스로 부터 여러 인스턴스가 생성되고 각각 다른 메모리 주소를 가짐

# 생성자

## 생성자
- 객체를 생성할 때 new 키워드와 함께 사용
- 생성자는 기능을 호출하는 것이 아님
- 생성자는 반환 값이 없고, 클래스 이름과 동일
- 매개 변수 없고 구현부 없음

## 기본 생성자
- 클래스에는 반드시 적어도 하나의 생성자가 있음
- 클래스에 생성자를 구현하지 않아도 new 키워드와 함께 생성자 호출 가능
- 클래스에 생성자 구현이 없어도 컴파일러가 생서자 코드를 알아서 넣어줌

## 생성자 overloading
- 이름은 같은데 매개변수가 달라서 다른 생성자를 만들 수 있게해줌


# 참조 자료형
## 참조 자료형
- 클래스형으로 변수를 선언
- 기본 자료형은 사용하는 메모리의 크기가 정해져있지만, 참조는 클래스에 따라 다름
- 참조 자료형을 사용할때는 해당 변수에 대해 생성

# STATIC
## 공통으로 사용하는 변수
- 여러 인스턴스가 공유하는 기준 값이 필요한 경우
- 인스턴스가 생성 될 때가 아닌 프로그램이 메모리에 올라올 때 생성
- 데이터 영역 메모리에 생성
- static 메서드에서는 인스턴스 변수를 사용할 수 없다

# Singleton 패턴
## 싱글톤 패턴이란?
- 프로그램에서 인스턴스가 단 한개만 생성되어야하는 경우
- static 변수, 메서드를 활용하여 구현

## 싱글톤 패턴으로 회사 객체 구현
- 생성자는 private으로 선언
- 클래스 내부에 유일한 private 인스턴스 생성
- 외부에서 유일한 인스턴스를 참조할 수 있는 public 메서드 제공


#  상속
## 클래스 상속
- 새로운 클래스를 정의할 때 이미 구현된 클래스를 상속 받아 속성이나 기능을 확장하여 사용
- 이미 구현된 클래스보다 구체적인 기능 등을 구현할 때 사용
```
class B extends A {
    // B 는 A를 포함
}
```

extends 키워드 뒤에는 단 하나의 클래스만 올 수 있음
자바는 단일 상속만 지원

## 상속을 구현하는 경우
- 상위 클래스는 하위 클래스보다 더 일반적인 개념을 가짐
- 하위 클래스는 상위 클래스보다 더 구체적
- 하위 클래스가 상위 클래스를 확장하는 의미

## 상속은 언제 사용할까?
### IS - A 관계 
- 일반적인 개념과 구체적인 개념과의 관계
- 상속은 클래스간 결합도가 높은 설계
- 상위 클래스가 하위 클래스에 영향을 미칠 수 있음
- 계층 구조가 복잡하거나 상속도가 높으면 좋지않음

### HAS - A 관계
- 클래스가 다른 클래스를 포함할 때
- 코드 재사용의 가장 일반적인 방법




## 상속에서 클래스 생성 과정과 형 변환

### 하위 클래스가 생성되는 과정
- 하위 클래스를 생성하면 상위 클래가 먼저 생성됨
- 클래스가 상속 받은 경우 하위 클래스의 생성자에는 무조건 상위 클래스의 생성자가 호출됌

### super 키워드
- 하위 클래스에서 상위 클래스에 대한 참조 값
- super()는 기본적으로 상위 클래스 생성자 호출
- 하위 클래스에서 명시적으로 상위 클래스 생성자를 호출 하지 않으면 super()가 호출됌
- 상위 클래스의 기본 생성자가 없는 경우 하위 클래스 생성자에서는 super를 이용하여 명시적으로 상위 클래스 생성자 호출
- super는 상위 클래스의 메서드나 속성에 접근

### 형 변환 ( 업 캐스팅 )
- 상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스 생성
- 상위 클래스 타입의 변수에 하위 클래스 변수가 대입
- 하위 클래스는 상위 클래스의 타입을 내포하므로 묵시적 형 변환 가능
- 상속 관계에서 모든 하위 클래스는 상위 클래스로 업 캐스팅 가능

### 다운 캐스팅
- 업 캐스팅된 클래스를 원 타입으로 변환
- 하위 클래스로의 형 변환은 명시적으로 해야함
- instanceof를 사용하여 인스턴스 형 체크

# 메서드 재정의 ( overridng )
##  하위 클래스에서 메서드 재정의하기

- Overriding: 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는경우 하위 클래스에서 동일한 이름의 메서드로 재정의 할 수 있음
- 재정의 하여 구현하는 것

## 애노테이션
- 애노테이션은 원래 주석의 의미
- 컴파일러에게 특별한 정보 제공

|애노테이션 | 설명                               |
|----|----------------------------------|
| @Overide | 재정의된 메서드라는 정보제공                  |
|@FuctionalInterface| 함수형 인터페이스라는 정보 제공                |
|@Deprecated| 이후 버전에서 사용되지 않을 수도 있는 변수,메서드에 사용 |
|@SuppressWarnings| 특정 경고가 안나타나게                     |

## 메서드 재정의와 가상 메서드 원리
### 메서드는 어떻게 정의되고 호출되는가

- 메서드의 이름은 주소값을 나타냄
- 메서드의 명령어는 set이고 프로그램이 로드되면 메서드의 영역에 명령어 set이 위치
- 해당 메서드가 호출되면 명령어 set이 있는 주소를 찾아 실행
- 이 때 메서드에서 사용하는 변수들은 스택 메모리에 위치
- 따라서 다른 인스턴스여도 메서드의 주소값은 같기 때문에 같은 메서드가 호출
- 인스턴스가 생성되면 변수는 힙 메모리에 생성되지만, 메서드 명령어 set은 처음 한번만 로드됌


# 다형성과 다형성을 사용하는 이유
## 다형성이란

- 하나의 코드가 여러 자료형으로 구현 되는것
- 같은 코드에서 여러 다른 실행 결과가 나옴
- 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징중 하나임
- 다형성을 잘 활용하면 유현하고 확장가능, 유지보수가 좋은 프로그램을 만들 수 있다

## 다형성을 사용하는 이유

- 다른 관련 객체를 생성하는 경우
- 상속과 메서드 재정의를 통해 확장성 있는 프로그램 구현
- 그렇지 않으면 수많은 if-else구문으로 처리
- 상위 클래스에서는 공통적인 부분을 제공하고 하위 클래스에서는 각 클래스에 맞는 기능 구현
- 여러 클래스를 하나의 타입으로 관리 가능


# 추상 클래스
## 추상 클래스란
- 구현 코드 없이 메서드의 선언만 있는 메서드
- 메서드 선언: 반환타입, 메서드 이름, 매개 변수로 구성
- 메서드 정의: 메서드 구현과 같은 말, 구현부를 가짐
- abstract 예약어 사용
- 추상 클래스는 new 불가

### 훅 메서드 -> 확장의 여지를 주는 메서드 ( 추상 메서드와 달리 빈 함수 구현 )

## 추상 클래스 구현하기
- 메서드에 구현 코드가 없으면 abstract로 선언
- abstract로 선언된 메서드를 가진 클래스는 abstract로 선언
- 모든 메서드가 구현된 클래스라도 abstract로 선언되면 추상 클래스로 인스턴스화 불가능
- 추상 클래스의 추상 메서드는 하위 클래스가 상속하여 구현
- 추상 클래스내의 추상 메서드 -> 하위 클래스가 구현해야하는 메서드
- 추상 클래스내의 구현 된 메서드 -> 하위 클래스들의 공통 사용 메서드

## 추상 클래스 응용 - 템플릿 패턴
### 템플릿 메서드

- 추상 메서드나 구현된 메서드를 사용하여 코드의 시나리오 정의
- final로 선언하여 하위 클래스에서 재정의 막음
- 프레임 워크에서 많이 사용
- 추상 클래스로 선언된 상위 클래스에서 시나리오를 구현하고 하위 클래스에서 다르게 구현되어야하는 부분은 추상 메서드로 선언하여 하위 메서드에서 재정의하게 만듬

## 인터페이스

- 모든 메서드가 추상 메서드로 되어있음
- 모든 변수는 상수로 선언 public static final
- 디폴드 메서드 ( java 8 이후): 인터페이스를 구현하는 객체에서 사용가능 default 키워드 사용
- 정적 메서드 ( java 8 이후): 인스턴스 생성과 상관없이 인터페이스 타입으로만 사용가능 static 키워드 사용
- private 메서드 ( java 9 이후): 인터페이스 구현한 곳에서 재정의 불가능, 인터페이스 내부에서만 사용 private 키워드 사용 ( default 나 static 메서드에서 사용 )

### 사용예시
- DB에 회원 정보를 넣는 dao(data access object)를 여러 DB 제품이 지원할 수 있게함
- 환경파일에서 database의 종류를 읽고 그 종류에 맞게 dao인스턴스를 생성하기
